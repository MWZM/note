####   <第一天>

##### <1>面向对象编程

######   1.面向过程：

​           面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。

######   2.面向对象：

​           面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作

   面向对象的三大特点：

                  1.封装
     
                  2.继承
      
                  3.多态

######   3.面向对象的优缺点：

         优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护
    
         缺点：性能比面向过程低

######   4.面向过程的优缺点：

         优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。
     
         缺点：不易维护、不易复用、不易扩展

 


##### <2>创造类和对象

  类：在 ES6 中新增加了类的概念，可以使用 class 关键字声明一个类

       1.利用class创建一个类，在类中可以添加属性和方法
    
          constructor：constructor 函数,可以接受传递过来的参数,同时返回实例对象    
    
       2. 利用类创建对象 new
    
          只要 new 生成实例时,就会自动调用constructor这个函数, 如果我们不写这个函数,类也会自动生成这个函数

##### <3>类的继承

   extends 子类可以继承父类的属性和方法

   super（）如果想要继承父类的方法,同时在自己内部扩展自己的方法,利用super 调用父类的构造函数,super 必须在子类this之前调用

<4>this指向问题

   遵循谁调用指向谁的原则

####   <第二天>

##### <1>静态成员和实例成员

######    实例成员:

​         实例成员就是构造函数内部通过this添加的成员 实例成员只能通过实例化的对象来访问

######    静态成员：

​          静态成员 在构造函数本身上添加的成员 静态成员只能通过构造函数来访问

##### <2>构造函数问题

   存在浪费内存的问题

##### <3>构造函数原型prototype

   构造函数通过原型分配的函数是所有对象所共享的

##### <4>原型链和成员的查找机制

   任何对象都有原型对象,也就是prototype属性,任何原型对象也是一个对象,该对象就有__proto__属性,这样一层一层往上找,就形成了一条链,我们称此为原型链

##### <5>原型对象中this指向

   不管构造函数中的this还是原型对象的this,都指向我们new出来的实例对象

##### <6>继承

###### 1 .call()

       call()可以调用函数


       call()可以修改this的指向,使用call()的时候 参数一是修改后的this指向,参数2,参数3..使用逗号隔开连接
    
    2.子构造函数继承父构造函数中的属性
    
           1. 先定义一个父构造函数


​           
2. ###### 再定义一个子构造函数


           3. 子构造函数继承父构造函数的属性(使用call方法)

##### <7>ES5 新增方法

###### 1.数组方法forEach遍历数组

arr.forEach(function(value, index, array) {

参数一是:数组元素

参数二是:数组元素的索引

参数三是:当前的数组

 })

  相当于数组遍历的 for 循环 没有返回值

###### 2.数组方法filter过滤数组

  ```
 返回的是一个新数组
  ```

###### 3.数组方法some

```
返回值是 true 或者 false
```



##### <1>some和forEach区别



       如果查询数组中唯一的元素, 用some方法更合适,在some 里面 遇到 return true 就是终止遍历 迭代效率更高


       在forEach 里面 return 不会终止迭代

##### <2>trim方法去除字符串两端的空格



##### <3>获取对象的属性名

       Object.keys(对象) 获取到当前对象中的属性名 ，返回值是一个数组

##### <4>Object.defineProperty

       Object.defineProperty设置或修改对象中的属性
    
                 1. value:修改或新增的属性的值,
    
    	 2. writable:true/false,  如果值为false 不允许修改这个属性值
    
    	 3. enumerable: false,enumerable   如果值为false 则不允许遍历
    
                 4. configurable: false  如果为false 则不允许删除这个属性 属性是否可以被删除或是否可以再次修改特性

##### <5> forEach()和map()区别：

     forEach()方法不会返回执行结果，而是undefined。也就是说，forEach()会修改原来的数组。而map()方法会得到一个新的数组并返回。

####   <JS>高级第三天


重写原型对象的结果： 重写原型对象切断了现有原型与任何之前已经存在的实例之间的联系，他们引用的仍然是最初的原型

##### <1> 函数的定义方式

   1. 方式声明

   2. 表达式声明

   3.new function

##### <2> 函数的调用

   1. 普通函数

   2. 对象方法的调用

   3. 构造函数

   4. 绑定事件

   5. 定时器函数

   6. 立即执行函数

##### <3> 函数内部this执指向

   谁调用就指向谁   除了构造函数以及箭头函数

##### <4> 改变函数内部this指向

   1. call（）方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向

       使用场景  经常用来做继承

   2. apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。

       使用场景  经常跟数组有关系

            apply 与 call 不同  apply 传递参数时必须以数组的形式进行传递

   3. bind() 方法不会调用函数,但是能改变函数内部this 指向,返回的是原函数改变this之后产生的新函数

       应用场景:不调用函数,但是还想改变this指向

            如果只是想改变 this 指向，并且不想调用这个函数的时候，可以使用bind

##### <5> call、apply、bind三者的异同

     共同点 : 都可以改变this指向
    
     不同点:  1. call 和 apply  会调用函数, 并且改变函数内部this指向.
    
              2. call 和 apply传递的参数不一样,call传递参数使用逗号隔开,apply使用数组传递
    
              3. bind  不会调用函数, 可以改变函数内部this指向.

##### <6> 高阶函数 

     高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。

##### <7> 闭包

     闭包指有权访问另一个函数作用域中变量的函数。
    
         作用：延伸变量的作用范围。
    
         可以让闭包中引用的变量始终保存在内存中。
    
     缺点：比普通函数更占内存
    
     如何解决：可以给最终输出结果进行手动赋值为 null ，这样可以避免内存中一直存在该变量

##### <8> 递归

     递归：如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。
    
         注意点： 递归函数的作用和循环效果一样，由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件return。



#### <JS>高级第四天

##### <1> let 可以声明一个块级作用域  不存在变量提升过 

        暂时性死区：利用let声明的变量会绑定在这个块级作用域，不会受外界的影响

##### <2> const 声明的变量是不可以进行更改的

    在声明一个数组或者对象后是不可以直接进行更改，但是可以替换其中的一些属性和元素

##### <3> 解构赋值：

​        解构赋值就是把数据结构分解，然后给变量进行赋值

         1. 数组解构：
    
               let [a, b, c] = [1, 2, 3];
    
               如果结构不成功则为undefined
     
         2. 对象解构
    
               let person = { name: 'zhangsan', age: 20 }; 
    
               let { name, age } = person;

##### <4> 箭头函数：

​         箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this

##### <5> 剩余参数：

​        剩余参数语法允许我们将一个不定数量的参数表示为一个数组，不定参数定义方式，这种方式很方便的去声明不知道参数情况下的一个函数

           表示方式：...

##### <6>Set：

​        可以和剩余参数进行配合进行数组去重